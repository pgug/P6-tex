\section{Rho-Calculus}
We are using rho-calculus because it is a small and simple calculus which is fast to learn.
It is developed and described by L. G. Meredith and M. Radestock in \citep{Meredith2005}.
We will use rho-calculus to model a system, and later a security type rule will be applied.
Because rho-calculus is a small calculus, there will not be many reduction rules to look through, and the type rules for the reduction rules will then be faster to make than with a bigger calculus.
The rho-calculus have a syntax for parallelism which will be useful for modelling client/server systems, were security can be an issue, and security can be a major part of the specification. 
Our syntax is similar to the one described in \citep{Meredith2005}, however our lift includes a term $M$ that will be explained in section \ref{sec:addsyntax}.
\begin{align*}
    P  ::= \; &  \nil & \text{nil} \\
      & \mid \inp{x}{y}P & \text{input} \\
      & \mid \lift{x}{M} & \text{lift} \\
      & \mid \drop{x} & \text{drop} \\
      & \mid P \para Q & \text{parallel} \\[3mm]
    x,y ::= \; & \quot{P} & \text{quote}\\
\end{align*}

\input{Sections/Syntax/description.tex}

\subsection{Additional Syntax} \label{sec:addsyntax}
Although it is possible to implement a blockchain protocol in the rho-calculus, it would require convoluted structures to express even simple concepts.
We choose to extend the rho-calculus to allow easier modeling of those concepts.\\
\\
We add an additional syntax rule for terms, where $M$ ranges over terms, $n$ ranges over numbers, $s$ ranges over strings and $f$ ranges over operations.
\begin{align*}
M::=\; & n &\text{number}\\
 &\mid s &\text{string}\\
 &\mid (M_1,...,M_k)\quad\quad\quad \text{for all k $\geq$ 2} &\text{tuple}\\
 &\mid fM &\text{operation}\\
 &\mid x &\text{name}\\
 \end{align*}
In addition to terms and processes we need to use conditional processes. This requires boolean expressions, denoted by \ensuremath{\phi}.
\begin{align*}
P::=& \ [\phi] P\\
\phi ::=& \ M_1\gamma M_2 \mid \phi\land\phi \mid \phi\lor\phi \mid \neg\phi \mid \top \mid \bot\\
\gamma ::=& \ = \mid \neq \mid < \mid > \mid \leq \mid \geq
\end{align*}
To ease the writing of conditional branching, we allow an if-then-else syntax.
\begin{align*}
	\If{\phi}{P}{Q} \eqdef [\phi].P \mid [\neg \phi].Q
\end{align*}


