\section{Rho-Calculus}\label{ch:rho-calculus}
We are using rho-calculus because it is a small and simple calculus which should be fast to learn.
It is developed and described by L. G. Meredith and M. Radestock in \citep{Meredith2005}.
We will use rho-calculus to model a system, and later a security type rule will be applied. We could maybe make the calculus even smaller but that would make it more difficult to express and model a system in it, we would actually want to expand it a little to make it easier to model a system in it.
Because rho-calculus is a small calculus, there will not be many reduction rules to look through, and the type rules for the reduction rules will then be few compared a bigger calculus.
The rho-calculus has a syntax for parallelism which will be useful for modelling client/server systems, where security can be an issue, and security can be a major part of the specification. 
%Our syntax is similar to the one described in \citep{Meredith2005}, however our lift includes a term $M$ that will be explained in section \ref{sec:addsyntax}.
The syntax here is as the syntax described in \citep{Meredith2005}, we would like to add some syntax rules on top on this, to make it easier to implement systems in the calculus.
\begin{align*}
    P  ::= \; &  \nil & \text{nil} \\
      & \mid \inp{x}{y}P & \text{input} \\
      & \mid \lift{x}{P} & \text{lift} \\
      & \mid \drop{x} & \text{drop} \\
      & \mid P \para Q & \text{parallel} \\[3mm]
    x,y ::= \; & \quot{P} & \text{quote}\\
\end{align*}

\input{Sections/Syntax/description.tex}

\subsection{Additional Syntax} \label{sec:addsyntax}
Although it is possible to implement a blockchain protocol in the rho-calculus, it would require convoluted structures to express even simple concepts.
We choose to extend the rho-calculus to allow easier modelling of those concepts.
We can do this with out making the rho-calculus stronger, because in the simple pi-calculus you can code a calculus with terms\citep{Baldamus2005}, and the simple pi-calculus can be coded in the rho-calculus\citep{Meredith2005}.\\
\\
We add an additional syntax rule for terms, where $M$ ranges over terms, $n$ ranges over numbers, $s$ ranges over strings and $f$ ranges over operations. We have also added a possibility of lifting a term, instead of a process.

In addition to terms and processes we need to use conditional processes. This requires boolean expressions, denoted by \ensuremath{\phi}.
\begin{align*}
P  ::= \; &  \nil & \text{nil} \\
      & \mid \inp{x}{y}P & \text{input} \\
	  & \mid \lift{x}{M}&\text{lift}\\
      & \mid \drop{x} & \text{drop} \\
      & \mid P \para Q & \text{parallel} \\
      & \mid [\phi] P\\[3mm]
    x,y ::= \; & \quot{P} & \text{quote}\\[3mm]
M::=\; & n &\text{number}\\
 	  &\mid s &\text{string}\\
 	  &\mid (M_1,...,M_k)\quad\quad\quad \text{for all k $\geq$ 2} &\text{tuple}\\
 	  &\mid fM &\text{operation}\\
 	  &\mid x &\text{name}\\[3mm]
\phi ::=& \mid M_1\gamma M_2 \mid \phi\land\phi \mid \phi\lor\phi \mid \neg\phi \mid \top \mid \bot\\[3mm]
\gamma ::=& \mid = \mid \neq \mid < \mid > \mid \leq \mid \geq
\end{align*}

To ease the writing of conditional branching, we allow an if-then-else syntax.
\begin{align*}
	\If{\phi}{P}{Q} \eqdef [\phi].P \mid [\neg \phi].Q
\end{align*}


