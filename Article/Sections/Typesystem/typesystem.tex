\section{Type Security}
In order to determine whether a protocol is secure or not, we need a model that can express security.
We will construct a type system on top of our existing calculus, that will include security levels.
That way we can define integrity as a behaviour of our types.
\begin{align*}
	S::=&\;T \tag{Term}\\
	&\mid T\ra T \tag{Operation}\\
	&\mid bool \tag{Boolean}\\
	T::=&\;U^l\\
	U::=&\;B \tag{Basic Term}\\
	&\mid ch[T] \tag{Channel}\\
	&\mid T_1 \times...\times T_k \tag{Tuple}\\
	B::=&\;number 
	\mid string\\
\end{align*}

\noindent The syntax of our type system is shown above. It is described as follows:

\begin{description}
\item[Terms] have a specialization type $U$ and a security level $l$. $l$ ranges over the natural numbers $\mathbb{N}_0$. This ensures an ordering between different security levels, where $0$ is considered the lowest level of security.
\item[Operations] have an argument type and a resulting type.
\item[Booleans] are used for the boolean expressions of conditional processes. These are not included as basic terms since they are not terms.
\item[Channels] allow terms of type $T$ to be sent and received.
\item[Tuples] have types composed of all the types of the contained terms.
\item[Basic Terms] are terms that do not require specialized type rules.
\end{description}

In the rest of this section, we denote the security level of term $T$ as $\level{T}$. This is defined by the following:
\begin{align*}
\tag{Level}\level{U^l}\eqdef l
\end{align*}

\subsection{Type Verification}

\begin{align*}
\tag{ValidOperation} &\infrule{\valid{T'}}{\valid{T\ra T'}}\\
\tag{ValidBoolean} &\valid{bool}\\
\tag{ValidBasicTerm} &\valid{B^l}\\
\tag{ValidChannel} &\infrule{\valid{U^l}\quad l\leq l'}{\valid{ch[U^l]^{l'}}}\\
\tag{ValidTuple} &\infrule{\forall i\ \valid{T_i}\quad \forall i\ \level{T_i}\leq l}{\valid{{T_1 \times...\times T_k}^l}}& where\ 1\leq i\leq k
\end{align*}

\subsection{Well-typing}
A type judgment $x:T$ denotes that $x$ is well-typed at type $T$.
These judgments can be collected to form a type environment, denoted $E$, that partially maps names to types.
\begin{align*}
E: \mathbf{Names} \rightharpoonup \mathbf{Types}
\end{align*}

\noindent $E\vdash x:T$ denotes that $x$ is well-typed at type $T$ in context $E$.
$E\vdash x$, where no type is provided, denotes that $x$ is simply well-typed. $E(x)$ denotes the actual type of $x$.

\begin{align*}
\tag{Lookup}\label{rule:lookup} &\infrule{E(M)=S\quad\valid{S}}{E\vdash M:S}
\end{align*}

The \ref{rule:lookup} rule states that, given context $E$, if the actual type of $x$ is $S$ and $S$ is a valid type, then $x$ is well-typed at type $S$. The validation of $S$ ensures that well-typed expressions can not have invalid types introduced from the type environment.
In order to rule if $x$ is well-typed at other types, we need to introduce subtyping. The subtyping $S\leq S'$ denotes that $S$ is a subtype of $S'$. 

%\begin{align*}
%\tag{LessOrEqual}\label{rule:lessorequal} &\infrule{S=S'}{S\leq S'}
%\end{align*}

%The \ref{rule:lessorequal} rule states that equal types are also subtypes of each other.

%\begin{align*}
%\tag{Transitive}\label{rule:transitive} &\infrule{S\leq S''\quad S''\leq S'}{S\leq S'}
%\end{align*}

%The \ref{rule:transitive} rule gives subtyping a transitive property.

\begin{align*}
\tag{Subtype} &\infrule{l\leq l'}{U^l\leq U^{l'}}
\end{align*}

\begin{align*}
\tag{Subsumption}\label{rule:subsumption} &\infrule{E\vdash M:T\quad T\leq T'}{E\vdash M:T'}
\end{align*}

The \ref{rule:subsumption} rule states that, given context $E$, if $x$ is well-typed at $T$ and $T$ is a subtype of $T'$, then $x$ is also well-typed at type $T'$. This is what allows a subtyping to maintain well-typing.

%\begin{align*}
%\tag{BasicSubBasic} &\infrule{l\leq l'}{B^l\leq B^{l'}}\\
%\tag{TupleSubTuple} &\infrule{S_i\leq S'\quad %U_i=S_i^\rho}{U_1\times...\times U_i\times...\times U_n\leq %U_1\times...\times S'^\rho\times...\times U_n}\\
%\tag{Level-level} &\level{l}=l\\
%\tag{Channel-level} &\level{ch[S]} = \level{S}\\
%\tag{Tuple-level} &\level{U_1\times...\times %U_n}=\max_{i=1}^{n}{\level{S_i}}& where\ S_i^\rho=U_i\\
%\tag{Basic-level} &\level{B^l}=l\\
%\tag{TypeSubLevel} &S\leq \level{S}\\
%\tag{TermAsChannel} &\infrule{E(M)=S^\rho\quad \level{S}=l}{E\vdash %M:ch[l]^\rho}
%\end{align*}

\begin{align*}
\tag{Nil} &E \vdash \nil\\
\tag{Input} &\infrule{E\vdash x:ch[T]^l\quad E,y:T\vdash P}{E \vdash \inp{x}{y}P}\\
\tag{Lift} &\infrule{E\vdash x:ch[T]^l\quad E \vdash M:T}{E\vdash \lift{x}{M}}\\
\tag{Drop} &\infrule{E \vdash P}{E\vdash \drop{x}}& where \drop{x} \equiv P\\
\tag{Parallel} &\infrule{E\vdash P \quad E \vdash Q}{E \vdash P \para Q}\\
\tag{Quote} &\infrule{E \vdash x:T}{E\vdash \quot{P}:T}& where\ \quot{P} \equiv_N x
\end{align*}

\begin{align*}
\tag{Condition} &\infrule{E\vdash \phi:bool\quad E\vdash P}{E \vdash [\phi] P}\\
\tag{Relation} &\infrule{E\vdash M_1:U^l\quad E\vdash M_2:U^{l'}}{E\vdash M_1 \gamma\ M_2:bool}\\
\tag{And} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \land \phi _2:bool}\\
\tag{Or} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \lor \phi _2:bool}\\
\tag{Negation} &\infrule{E\vdash \phi :bool }{E\vdash \neg \phi :bool}\\
\tag{True} &E\vdash\top:bool\\
\tag{False} &E\vdash\bot:bool\\
\tag{Operation} &\infrule{E\vdash f:T\ra T'\quad E\vdash M:T}{E\vdash fM:T'}\\
\tag{Tuple} &\infrule{\level{T_i}=l\quad\forall i\ \level{T_i}\leq l\quad\forall i\ E\vdash M_i:T_i}{E\vdash (M_1,...,M_k):{T_1\times...\times T_k}^l}& where\ 1\leq i\leq k\\
\tag{Int} &E\vdash n:{number^0}\\
\tag{String} &E\vdash s:{string^0}\\
\end{align*}

%\textit{max(T)} is a operation which returns the maximum value off its input \textit{T}, according to the input \textit{T}s order.

%\begin{align*}
%\tag{Append} &\infrule{E \vdash x:T^l \quad E \vdash y:list^l}{E \vdash append(x,y):list^l}\\
%\tag{Head} &\infrule{E \vdash x:list^l}{E \vdash head(x):l}\\
%\tag{Tail} &\infrule{E \vdash x:list^l}{E \vdash tail(x):list^l}\\
%\tag{newBlock}& \infrule{E \vdash data:T \quad E \vdash previus : T}{E \vdash newBlock(data, previus) :T}\\
%\tag{getLatest}& \infrule{E \vdash chain :T}{E \vdash getLatest(chain):T}\\
%\tag{addToChain}& \infrule{E \vdash block:T \quad E \vdash chain:T}{E \vdash addToChain(block, chain):T}\\
%\tag{getLenght}& \infrule{E \vdash chain:T}{E \vdash getLenght(chain):int}\\
%\tag{isValid}& \infrule{E \vdash chain:T}{E \vdash isValid(chain):bool}
%\end{align*}

\subsection{Subject Reduction}
If \ensuremath{E \vdash P} and \ensuremath{P\ra P'} then \ensuremath{E \vdash P'}.
We have to show that \ensuremath{\frac{}{P \ra P'}} holds for the rules, parallel, communication and structural congruent, for it to hold.

\textbf{Parallel}
\begin{align*}
\infrule{P \ra P'}{P \para Q \ra P' \para Q}
\end{align*}
If \ensuremath{E \vdash P} and \ensuremath{P \ra P'} then \ensuremath{E \vdash P'} We want to show that if \ensuremath{E \vdash P \para Q} then \ensuremath{E \vdash P' \para Q}. The type rule for parallel say \ensuremath{\frac{E \vdash P\quad E \vdash Q}{E \vdash P \para Q}} so if \ensuremath{E \vdash P'} then \ensuremath{\frac{E \vdash P' \quad E \vdash Q}{E \vdash P' \para Q}}

\textbf{Communication}
\begin{align*}
\infrule{}{\lift{x}{M}\para\inp{x}{y}P\ra P\{M/y\}}
\end{align*}

Lemma Substitution
If \ensuremath{E,x:T \vdash P} and \ensuremath{E_2 \vdash M:T} then \ensuremath{E, E_2 \vdash P\{M/x \}}

\textbf{Structural Congruent}
\begin{align*}
\infrule{P\equiv P'\quad P'\ra Q'\quad Q'\equiv Q}{P\ra Q}
\end{align*}

If \ensuremath{E \vdash P} then \ensuremath{E \vdash P'} We will want to show that if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q'}

Lemma Equivalent
If \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q}

By applying lemma equivalent to the structural congruent, we see that because \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q} and because \ensuremath{P \ra P'} and \ensuremath{E \vdash P'} then \ensuremath{E \vdash Q'}.

\subsection{Well typed}
If \ensuremath{E\vdash P} then \ensuremath{P\nrightarrow wrong}

If \ensuremath{E \vdash P} then \ensuremath{E \vdash P \nrightarrow wrong} and if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q \nrightarrow wrong}. This makes it so that that \ensuremath{E \vdash P \para Q \nrightarrow wrong}
\\\\

If \ensuremath{P \ra wrong} then must \ensuremath{P \para Q \ra wrong} true.\\
If \ensuremath{P \ra wrong} and \ensuremath{P \equiv Q} then must \ensuremath{Q \ra wrong} be true.

\begin{align*}
\tag{Action} & \infrule{E \vdash P \quad P\ra P'}{E\vdash P'}\\
\tag{Not Wrong}& \infrule{E \vdash P}{P \nrightarrow wrong}\\
\tag{Para Wrong}& \infrule{P \ra wrong}{P\para Q \ra wrong}\\
\tag{Wrong}& \infrule{E(x) = ch[T_1] \quad E \vdash M:T_2 \quad \level{T_2} > \level{T_1} }{\lift{x}{M} \ra wrong}
\end{align*}


%\fig{M: secret,c:secure\vdash \lift{c}{M}}{If \textit{M} is of type \textit{secret}, then \textit{c} should be of type \textit{secure}}{fig:sec}
%
%\fig{\frac{\Gamma \vdash M:Secret \quad \Gamma \vdash c:Secure}{\Gamma \vdash \lift{c}{M}}}{}{secret}
%
%\fig{\frac{\Gamma \vdash M:Public \quad \Gamma \vdash c:Insecure}{\Gamma \vdash \lift{c}{M}}}{}{public}

\FloatBarrier
