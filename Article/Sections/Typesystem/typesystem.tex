\section{Type Security}
In order to determine whether a protocol is secure or not, we need a model that can express security.
We will construct a type system on top of our existing calculus, that will include security levels.
That way we can define integrity as a behaviour of our types.
\begin{align*}
	T::=&l \tag{Security Level}\\
	\mid& ch[T] \tag{Channel}\\
	\mid& B^l \tag{Type}\\
	\mid& T \times T \tag{Cardinality}\\
	B::=&int 
	\mid string 
	\mid list 
	\mid bool 
\end{align*}

\noindent The syntax of our type system is shown above.
$l$ are the security levels that ranges over $\mathbb{N}_0$.
This ensures an ordering between different security levels.

\begin{description}
\item[Security level] is the level of security and ranges over natural number $\mathbb{N}_0$.
\item[Channel] have a security level $l$ where T is send. T must be of a security level $l$ equal to or below the the channels security level $l$.
\item[Type] have a security level $l$.
\item[Cardinality] \todo{Frandsen forklar!!!}
\end{description}

Below is the Type environment E that partially maps names to types.
\begin{align*}
E: names \rightharpoonup types
\end{align*}

\noindent A type judgment $x:T$ denotes that $x$ is well-typed at type $T$.
These judgments can be collected to form a type environment, denoted $E$, that partially maps names to types.
$E\vdash x:T$ denotes that $x$ is well-typed at type $T$ in context $E$.
If $x$ is not given a type, then it is simply well-typed.


\begin{align}
\tag{Nil} &E \vdash \nil\\
\tag{Input} &\infrule{E\vdash x:ch[T]\quad E,y:T\vdash P}{E \vdash \inp{x}{y}P}\\
\tag{Lift} &\infrule{E\vdash x:ch[T]\quad E \vdash M:T}{E\vdash \lift{x}{M}}\\
\tag{drop} &\infrule{E \vdash P}{E\vdash \drop{x}}& where \drop{x} \equiv P\\
\tag{Parallel} &\infrule{E\vdash P \quad E \vdash Q}{E \vdash P \para Q}\\
\tag{Quot} &\infrule{E \vdash x}{E\vdash \quot{P}}& where\ \quot{P} \equiv_N x
\end{align}

\begin{align}
\tag{Bool} &\infrule{E\vdash \phi:bool\quad E\vdash P}{E \vdash [\phi] P}\\
\tag{Condition} &\infrule{E\vdash M_1:T \quad E\vdash M_2:T}{E\vdash M_1 \gamma\ M_2:bool}\\
\tag{And} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \land \phi _2:bool}\\
\tag{Or} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \lor \phi _2:bool}\\
\tag{Negation} &\infrule{E\vdash \phi :bool }{E\vdash \neg \phi :bool}\\
\tag{Operation} &\infrule{E\vdash f:T\ra T'\quad E\vdash M:T}{E\vdash fM:T'}\\
\tag{Tuple} &\infrule{E\vdash M_i:T_i \quad (1\leq i\leq n)}{E\vdash (M_1,...,M_n):T_1\times ...\times T_n}\\
\tag{Int} &E\vdash n: int^l\\
\tag{String} &E\vdash s:string^l\\
\tag{Subsumption} &\infrule{T\leq T'}{E, M:T\vdash M:T'}
\end{align}


\textit{max(T)} is a operation which returns the maximum value off its input \textit{T}, according to the input \textit{T}s order.
\begin{align}
\tag{Append} &\infrule{E \vdash x:T^l \quad E \vdash y:list^l}{E \vdash append(x,y):list^l}\\
\tag{Head} &\infrule{E \vdash x:list^l}{E \vdash head(x):l}\\
\tag{Tail} &\infrule{E \vdash x:list^l}{E \vdash tail(x):list^l}\\
\tag{newBlock}& \infrule{E \vdash data:T \quad E \vdash previus : T}{E \vdash newBlock(data, previus) :T}\\
\tag{getLatest}& \infrule{E \vdash chain :T}{E \vdash getLatest(chain):T}\\
\tag{addToChain}& \infrule{E \vdash block:T \quad E \vdash chain:T}{E \vdash addToChain(block, chain):T}\\
\tag{getLenght}& \infrule{E \vdash chain:T}{E \vdash getLenght(chain):int}\\
\tag{isValid}& \infrule{E \vdash chain:T}{E \vdash isValid(chain):bool}
\end{align}

\begin{align}
\tag{Action} & \infrule{E \vdash P \quad P\ra P'}{E\vdash P'}\\
\tag{Not Wrong}& \infrule{E \vdash P}{P \nrightarrow wrong}\\
\tag{Para Wrong}& \infrule{P \ra wrong}{P\para Q \ra wrong}\\
\tag{Wrong}& \infrule{E(x) = ch^l[T] \quad E \vdash M:T \quad L(T) > l }{\lift{x}{M} \ra wrong}\\
\end{align}


%\fig{M: secret,c:secure\vdash \lift{c}{M}}{If \textit{M} is of type \textit{secret}, then \textit{c} should be of type \textit{secure}}{fig:sec}
%
%\fig{\frac{\Gamma \vdash M:Secret \quad \Gamma \vdash c:Secure}{\Gamma \vdash \lift{c}{M}}}{}{secret}
%
%\fig{\frac{\Gamma \vdash M:Public \quad \Gamma \vdash c:Insecure}{\Gamma \vdash \lift{c}{M}}}{}{public}

\FloatBarrier
