\section{Type System}\label{ch:type-security}
In order to determine whether a protocol is secure or not, we need a model that can express security.
We will construct a type system on top of our existing calculus, that will include security levels.
These levels allow us to isolate the client, by giving it higher security levels than the environment surrounding it.
If the type system prevents anything with some security level from being accessible to an environment with a lower security level, then the client gains integrity even in a malicious environment.
Because these levels are part of our type system, we can define integrity as a behaviour of our types.
\begin{align*}
    T::=&\;U^l\\    	
    U::=&\;B \tag{Basic Type}\\
        &\mid ch[T] \tag{Channel}\\
        &\mid T_1 \times...\times T_k \tag{Tuple}\\
        &\mid T\ra T \tag{Operation}\\
    B::=&\;number 
        \mid string
        \mid bool\\
\end{align*}

\noindent The syntax of our type system is shown above. It is described as follows:

\begin{description}
    \item[Terms] have a specialization type $U$ and a security level $l$.
        $l$ ranges over the natural numbers $\mathbb{N}_0$.
        This ensures an ordering between different security levels, where $0$ is considered the lowest level of security.
    \item[Operations] have an argument type and a resulting type.
    \item[Booleans] are used for the boolean expressions of conditional processes.
        These are not included as basic terms since they are not terms.
    \item[Channels] allow terms of type $T$ to be sent and received.
    \item[Tuples] have types composed of all the types of the contained terms.
    \item[Basic Type] are types that do not require specialized type rules.
\end{description}

In the rest of this section, we denote the security level of type $T$ as $\level{T}$.
This is defined by the following:
\begin{align*}
    \tag{Level}\level{U^l}\eqdef l
\end{align*}

\subsection{Type Validation}
With the syntax of our type system, it is possible to make types with some security level that consist of types with lower security level.
This could allow anything with some security level to disguise itself as a lower security level, allowing it to be accessed by environments of lower security level.
To avoid this we introduce type validation, where $\valid{T}$ denotes that the type $T$ is valid.

\begin{align*}
\tag{ValidSubsumption}\label{rule:ValidSublevel} &\infrule{\valid{T}\quad T\leq T'}{\valid{T'}}
\end{align*}

\begin{align*}
    \tag{ValidBasicTerm}\label{rule:ValidBasicTerm} &\valid{B^l}
\end{align*}
The \ref{rule:ValidBoolean} and \ref{rule:ValidBasicTerm} rules state that the boolean type and the basic term types are trivially valid.
This is true since they do not consist of any other types.

\begin{align*}
    \tag{ValidOperation}\label{rule:ValidOperation} &\infrule{\valid{U'^l}}{\valid{(U^l\ra U'^l)^{l}}}
\end{align*}
The \ref{rule:ValidOperation} rule states that an operation type is valid if its resulting type is valid.
The type system ensures that an operation only can be applied to a valid argument type, so it would be redundant to validate the argument type again.

\begin{align*}
    \tag{ValidChannel}\label{rule:ValidChannel} &\infrule{\valid{U^l}}{\valid{ch[U^l]^{l}}}
\end{align*}

The \ref{rule:ValidChannel} rule states that a channel type is valid if the type sent by the channel type is valid and has at most the security level of the channel type.
This ensures that channels can not send terms of some security level on a channel of lower security and possibly making it accessible to an environment of lower security level.

\begin{align*}
    \tag{ValidTuple}\label{rule:ValidTuple} &\infrule{\forall i\ \valid{U_i^l}}{\valid{{U_1^l \times...\times U_k^l}^l}}& where\ 1\leq i\leq k
\end{align*}
The \ref{rule:ValidTuple} rule states that a tuple type is valid if all its composite types are valid and all their security levels are at most the security level of the tuple type.
This ensures that a tuple with some security level does not contain terms with a higher security level than what should be accessible to an environment with that security level.

\subsection{Well-typing}
In order to give types to process' in our extended rho-calculus, we need to introduce well-typing.
A type judgment $x:T$ denotes that $x$ is well-typed at type $T$.
These judgments can be collected to form a type environment, denoted $E$, that partially maps $\mathbf{Names}$ to $\mathbf{Types}$.
\begin{align*}
    E: \mathbf{Names} \rightharpoonup \mathbf{Types}
\end{align*}

\noindent $E\vdash x:T$ denotes that $x$ is well-typed at type $T$ in context $E$.
$E\vdash x$, where no type is provided, denotes that $x$ is simply well-typed.
$E(x)$ denotes the actual type of $x$.

\begin{align*}
    \tag{Lookup}\label{rule:lookup} &\infrule{E(x)=T\quad\valid{T}}{E\vdash x:T}
\end{align*}

The \ref{rule:lookup} rule states that, given context $E$, if the actual type of $x$ is $S$ and $S$ is a valid type, then $x$ is well-typed at type $S$.
The validation of $S$ ensures that well-typed process' can not have invalid types originating from the type environment.

\subsection{Subtyping}
In order to state that an process is well-typed at other types, we need to introduce subtyping.
The subtyping $S\leq S'$ denotes that $S$ is a subtype of $S'$. 

\begin{align*}
    \tag{Subtype}\label{rule:subtype} &\infrule{l\leq l'}{U^l\leq U^{l'}}
\end{align*}

The \ref{rule:subtype} rule states that if $l$ is at most $l'$, then a term with security level $l$ is a subtype of a term with security level $l'$ that shares the same specialization type.
For example, $string^2$ is a subtype of $string^4$, since $2\leq4$ and the specialization types of both terms is $string$.

\begin{align*}
    \tag{Subsumption}\label{rule:subsumption} &\infrule{E\vdash x:T\quad T\leq T'}{E\vdash x:T'}
\end{align*}

The \ref{rule:subsumption} rule states that, given context $E$, if $x$ is well-typed at $T$ and $T$ is a subtype of $T'$, then $x$ is also well-typed at type $T'$.
Together with the \ref{rule:subtype} rule this states that, if $T$ is a term, then $x$ remains well-typed at higher security levels of $T$.

\subsection{Well-typing of process'}
In order to use the type system with process' in our extended rho-calculus, we need to define the well-typing of all process'.
This is done by providing type rules that cover our syntax and consequently any process' in our syntax.
\begin{align*}
    \tag{Nil}\label{rule:Nil} &E \vdash \nil
\end{align*}
The \ref{rule:Nil} rule states that any nil process is trivially well-typed.
This is true since the process contains no types.

\begin{align*}
    \tag{Input}\label{rule:Input} &\infrule{E\vdash x:ch[T]^l\quad E,y:T\vdash P}{E \vdash \inp{x}{y}P}
\end{align*}
The \ref{rule:Input} rule states that, given context $E$, if $x$ is well-typed at a channel type, that communicates type $T$, and $P$ is well-typed in a context where $y$ is well-typed at $T$, then $x(y).P$ is well-typed.
This ensures that communication is done on a channel and that $y$ has the type communicated by the channel when proceeding with $P$.

\begin{align*}
    \tag{Lift}\label{rule:Lift} &\infrule{E\vdash x:ch[T]^l\quad E \vdash M:T}{E\vdash \lift{x}{M}}
\end{align*}
The \ref{rule:Lift} rule states that, given context $E$, if $x$ is well-typed at a channel type, that communicates type $T$ and $M$ is well-typed at $T$, then $\lift{x}{M}$ is well-typed.
This ensures that communication is done on a channel and that $M$ has the type communicated by the channel.

\begin{align*}
    \tag{Drop}\label{rule:Drop} &\infrule{E \vdash P}{E\vdash \drop{x}}& where \drop{x} \equiv P
\end{align*}
The \ref{rule:Drop} rule states that, given context $E$, if the resulting process of dropping $x$ is well-typed, then dropping $x$ is well-typed.

\begin{align*}
    \tag{Parallel}\label{rule:Parallel} &\infrule{E\vdash P \quad E \vdash Q}{E \vdash P \para Q}
\end{align*}
The \ref{rule:Parallel} rule states that two well-typed processes in parallel is also a well-typed process.

\begin{align*}
    \tag{Quote}\label{rule:Quote} &\infrule{E \vdash x:T}{E\vdash \quot{P}:T}& where\ \quot{P} \equiv_N x
\end{align*}
The \ref{rule:Quote} rule states that, given context $E$, if the resulting name of quoting $P$ is well-typed at type $T$, then quoting $P$ is also well-typed at $T$.

\begin{align*}
    \tag{Condition}\label{rule:Condition} &\infrule{E\vdash \phi:bool^l\quad E\vdash P}{E \vdash [\phi] P}
\end{align*}
The \ref{rule:Condition} rule states that, given context $E$, if $\phi$ is well-typed at $bool$ and $P$ is well-typed, then the conditional process $[\phi]P$ is also well-typed. This ensures that the condition always evaluates to a boolean value.
\begin{align*}
    \tag{And}\label{rule:And} &\infrule{E\vdash \phi_1:bool^l\quad E\vdash \phi_2:bool^l}{E\vdash \phi _1 \land \phi _2:bool^{l}}\\
    \tag{Or}\label{rule:Or} &\infrule{E\vdash \phi_1:bool^l\quad E\vdash \phi_2:bool^l}{E\vdash \phi _1 \lor \phi _2:bool^{l}}\\
    \tag{Negation}\label{rule:Negation} &\infrule{E\vdash \phi :bool^l }{E\vdash \neg \phi :bool^l}
\end{align*}
\begin{align*}
    \tag{True}\label{rule:True} &E\vdash\top:bool^0\\
    \tag{False}\label{rule:False} &E\vdash\bot:bool^0
\end{align*}
The \ref{rule:And}, \ref{rule:Or} and \ref{rule:Negation} rules ensure that the $bool$ type is closed under these boolean operators. The \ref{rule:True} and \ref{rule:False} rules state that $\top$ and $\bot$ are trivially well-typed at $bool$.

\begin{align*}
    \tag{Relation}\label{rule:Relation} &\infrule{E\vdash M_1:U^l\quad E\vdash M_2:U^l}{E\vdash M_1 \gamma\ M_2:bool^{l}}
\end{align*}
The \ref{rule:Relation} rule states that, given context $E$, if the terms $M_1$ and $M_2$ shares the same specialization type, then $M_1\gamma M_2$ is well-typed at $bool$. This ensures that the two terms are comparable with each other.

\begin{align*}
    \tag{Number}\label{rule:Number} &E\vdash n:{number^0}\\
    \tag{String}\label{rule:String} &E\vdash s:{string^0}
\end{align*}
The \ref{rule:Number} rule states that $n$ is trivially well-typed at $number^0$.
The \ref{rule:String} rule states that $s$ is trivially well-typed at $string^0$.
They both ensure that any numbers and strings used statically in the protocol have the lowest level of security possible, since the protocol is accessible to all environments.

\begin{align*}
    \tag{Tuple}\label{rule:Tuple} &\infrule{\forall i\ E\vdash M_i:T_i\quad \forall i\ \level{T_i}\leq l}{E\vdash (M_1,...,M_k):{T_1\times...\times T_k}^l}& where\ 1\leq i\leq k
\end{align*}
The \ref{rule:Tuple} rule states that, given context $E$, if some terms are well-typed at some types, and the highest security level of those types is $l$, then a tuple containing those terms are well-typed at the composition of the types the terms are well-typed at where the composition has a security level of $l$.
This ensures that the tuple type can not be composed of types with higher security level than itself.

\begin{align*}
    \tag{Operation}\label{rule:Operation} &\infrule{E\vdash f:T\ra T'\quad E\vdash M:T}{E\vdash fM:T'}
\end{align*}
The \ref{rule:Operation} rule states that, given context $E$, if $f$ is well-typed at a operation type and $M$ is well-typed at the argument type of that operation type, then $fM$ is well-typed at the resulting type of that operation type.
This ensures that any argument used with an operation follows the type definition of the operation.

\section{Type Security}

\begin{theorem}[Subject Reduction]
If \ensuremath{E \vdash P} and \ensuremath{P\ra P'} then \ensuremath{E \vdash P'}.
To show that, we have to prove that \ensuremath{P \ra P'} holds for the rules, parallel, communication and structural congruent. We can do that by prove it by induction for the cases \ensuremath{n} and \ensuremath{n+1}.

\begin{proof}[Parallel]
\begin{align*}
    \frac{P \ra P' \quad =n}{P \para Q \ra P' \para Q} =n+1 \tag{Parallel}
\end{align*}
If \ensuremath{E \vdash P} and \ensuremath{P \ra P'} then \ensuremath{E \vdash P'} We want to show that if \ensuremath{E \vdash P \para Q} then \ensuremath{E \vdash P' \para Q}. The type rule for parallel say \ensuremath{\frac{E \vdash P\quad E \vdash Q}{E \vdash P \para Q}} so if \ensuremath{E \vdash P'} then \ensuremath{\frac{E \vdash P' \quad E \vdash Q}{E \vdash P' \para Q}}
\end{proof}

\begin{proof}[Communication]
\begin{align*}
    \infrule{}{\lift{x}{M}\para\inp{x}{y}P\ra P\{M/y\}} \tag{Communication}
\end{align*}

\begin{lemma}[Substitution]
If \ensuremath{E,x:T \vdash P} and \ensuremath{E_2 \vdash M:T} then \ensuremath{E, E_2 \vdash P\{M/x \}}
\end{lemma}

\end{proof}

\begin{proof}[Structural Congruent]
\begin{align*}
    \infrule{P \equiv P' \quad P' \ra Q' \quad Q' \equiv Q}{P \ra Q} \tag{Structural Congruent}
\end{align*}

If \ensuremath{E \vdash P} then \ensuremath{E \vdash P'} We will want to show that if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q'}

\begin{lemma}[Equivalent]
If \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q}
\end{lemma}

By applying lemma equivalent to the structural congruent, we see that because \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q} and because \ensuremath{P \ra P'} and \ensuremath{E \vdash P'} then \ensuremath{E \vdash Q'}.
\end{proof}

\end{theorem}




\begin{theorem}[Well typed]
If \ensuremath{E\vdash P} then \ensuremath{P\nrightarrow wrong}

\begin{proof}
If \ensuremath{E \vdash P} then \ensuremath{E \vdash P \nrightarrow wrong} and if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q \nrightarrow wrong}. This makes it so that that \ensuremath{E \vdash P \para Q \nrightarrow wrong}
\end{proof}

\end{theorem}



\begin{theorem}
If \ensuremath{E \vdash P} then \ensuremath{P \nrightarrow wrong}
\begin{proof}
We can have a \ensuremath{P} where \ensuremath{P \nrightarrow wrong} and where \ensuremath{E \nvdash P}
Example: \ensuremath{\lift{x}{true}\para \inp{y}{z}\inp{x}{w}\lift{y}{w+5}} \ensuremath{E=x:ch[bool], y:ch[int]} Because \ensuremath{y} never receive its messages we never get to receive on x where the error will occur where \ensuremath{w} should of type \ensuremath{int} because of \ensuremath{y} but actually is a \ensuremath{bool}.
\end{proof}
\end{theorem}

\subsubsection{Definition: Wrong}
\ensuremath{E \vdash P \ra wrong} 
\begin{proof}
To show when \ensuremath{P} goes \ensuremath{wrong} we need show every case where \ensuremath{P} goes \ensuremath{wrong}.\\
\textbf{Lift} \begin{align*}
\frac{E \nvdash M}{E \vdash \lift{x}{M} \ra wrong}\\
\frac{E \vdash M:T_1 \quad E(x)=ch[T_2]}{E \vdash \lift{x}{M} \ra wrong} &where T_1 \neq T_2
\end{align*}

\textbf{Input} \begin{align*}
\frac{\exists M,\quad E \vdash P\{ M/ y\} \ra wrong \quad E \vdash M:T \quad E(x)= ch[T]} {E \vdash \inp{x}{y}P \ra wrong}\\
\end{align*}

\textbf{Parallel} \begin{align*}
\frac{E \vdash P \ra wrong}{E \vdash P \para Q \ra wrong}
\end{align*}

\textbf{Structural Congruens} \begin{align*}
\frac{E \vdash Q \quad P \equiv Q}{E \vdash P \ra wrong}
\end{align*}

\textbf{Drop}\begin{align*}
\frac{\drop{x} \equiv P \quad E \vdash P \ra wrong}{E \vdash \drop{x} \ra wrong}
\end{align*}

\textbf{Quot}\begin{align*}
\frac{\quot{P} \equiv _N x \quad E \vdash P \ra wrong}{E \vdash \drop{x} \ra wrong}
\end{align*}

\textbf{Condition}\begin{align*}
\frac{E \vdash P \ra wrong}{E \vdash [\phi]P \ra wrong}
\end{align*}

\end{proof}
%\end{theorem}


%\begin{align*}
%    \tag{Wrong}& \infrule{E(x) = ch[T_1] \quad E \vdash M:T_2 \quad \level{T_2} > \level{T_1} }{\lift{x}{M} \ra wrong}
%\end{align*}


\FloatBarrier
