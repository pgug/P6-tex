\section{Type System}\label{ch:type-security}
In order to determine whether a protocol is secure or not, we need a model that can express security.
We will construct a type system on top of our existing calculus, that will include security levels.
These levels allow us to isolate the client, by giving it higher security levels than the environment surrounding it.
If the type system prevents anything with some security level from being accessible to an environment with a lower security level, then the client gains integrity even in a malicious environment.
Because these levels are part of our type system, we can define integrity as a behavior of our types.
\begin{align*}
    S::=&\;T \tag{Term}\\
        &\mid T\ra T \tag{Operation}\\
        &\mid bool \tag{Boolean}\\
    T::=&\;U^l\\
    U::=&\;B \tag{Basic Term}\\
        &\mid ch[T] \tag{Channel}\\
        &\mid T_1 \times...\times T_k \tag{Tuple}\\
    B::=&\;number 
        \mid string\\
\end{align*}

\noindent The syntax of our type system is shown above. It is described as follows:

\begin{description}
    \item[Terms] have a specialization type $U$ and a security level $l$.
        $l$ ranges over the natural numbers $\mathbb{N}_0$.
        This ensures an ordering between different security levels, where $0$ is considered the lowest level of security.
    \item[Operations] have an argument type and a resulting type.
    \item[Booleans] are used for the boolean expressions of conditional processes.
        These are not included as basic terms since they are not terms.
    \item[Channels] allow terms of type $T$ to be sent and received.
    \item[Tuples] have types composed of all the types of the contained terms.
    \item[Basic Terms] are terms that do not require specialized type rules.
\end{description}

In the rest of this section, we denote the security level of term $T$ as $\level{T}$.
This is defined by the following:
\begin{align*}
    \tag{Level}\level{U^l}\eqdef l
\end{align*}

\subsection{Type Validation}
With the syntax of our type system, it is possible to make types with some security level that consist of types with lower security level.
This could allow anything with some security level to disguise itself as a lower security level, allowing it to be accessed by environments of lower security level.
To avoid this we introduce type validation, where $\valid{S}$ denotes that the type $S$ is valid.

\begin{align*}
    \tag{ValidBoolean}\label{rule:ValidBoolean} &\valid{bool}\\
    \tag{ValidBasicTerm}\label{rule:ValidBasicTerm} &\valid{B^l}
\end{align*}
The \ref{rule:ValidBoolean} and \ref{rule:ValidBasicTerm} rules state that the boolean type and the basic term types are trivially valid.
This is true since they do not consist of any other types.

\begin{align*}
    \tag{ValidOperation}\label{rule:ValidOperation} &\infrule{\valid{T'}}{\valid{T\ra T'}}
\end{align*}
The \ref{rule:ValidOperation} rule states that an operation type is valid if its resulting type is valid.
The type system ensures that an operation only can be applied to a valid argument type, so it would be redundant to validate the argument type again.

\begin{align*}
    \tag{ValidChannel}\label{rule:ValidChannel} &\infrule{\valid{U^l}\quad l\leq l'}{\valid{ch[U^l]^{l'}}}
\end{align*}

The \ref{rule:ValidChannel} rule states that a channel type is valid if the type sent by the channel type is valid and has at most the security level of the channel type.
This ensures that channels can not send terms of some security level on a channel of lower security and possibly making it accessible to an environment of lower security level.

\begin{align*}
    \tag{ValidTuple}\label{rule:ValidTuple} &\infrule{\forall i\ \valid{T_i}\quad \forall i\ \level{T_i}\leq l}{\valid{{T_1 \times...\times T_k}^l}}& where\ 1\leq i\leq k
\end{align*}
The \ref{rule:ValidTuple} rule states that a tuple type is valid if all its composite types are valid and all their security levels are at most the security level of the tuple type.
This ensures that a tuple with some security level does not contain terms with a higher security level than what should be accessible to an environment with that security level.

\subsection{Well-typing}
In order to give types to expressions in our extended rho-calculus, we need to introduce well-typing.
A type judgment $x:T$ denotes that $x$ is well-typed at type $T$.
These judgments can be collected to form a type environment, denoted $E$, that partially maps $\mathbf{Names}$ to $\mathbf{Types}$.
\begin{align*}
    E: \mathbf{Names} \rightharpoonup \mathbf{Types}
\end{align*}

\noindent $E\vdash x:T$ denotes that $x$ is well-typed at type $T$ in context $E$.
$E\vdash x$, where no type is provided, denotes that $x$ is simply well-typed.
$E(x)$ denotes the actual type of $x$.

\begin{align*}
    \tag{Lookup}\label{rule:lookup} &\infrule{E(x)=S\quad\valid{S}}{E\vdash x:S}
\end{align*}

The \ref{rule:lookup} rule states that, given context $E$, if the actual type of $x$ is $S$ and $S$ is a valid type, then $x$ is well-typed at type $S$.
The validation of $S$ ensures that well-typed expressions can not have invalid types originating from the type environment.

\subsection{Subtyping}
In order to state that an expression is well-typed at other types, we need to introduce subtyping.
The subtyping $S\leq S'$ denotes that $S$ is a subtype of $S'$. 

%\begin{align*}
%\tag{LessOrEqual}\label{rule:lessorequal} &\infrule{S=S'}{S\leq S'}
%\end{align*}

%The \ref{rule:lessorequal} rule states that equal types are also subtypes of each other.

%\begin{align*}
%\tag{Transitive}\label{rule:transitive} &\infrule{S\leq S''\quad S''\leq S'}{S\leq S'}
%\end{align*}

%The \ref{rule:transitive} rule gives subtyping a transitive property.

\begin{align*}
    \tag{Subtype}\label{rule:subtype} &\infrule{l\leq l'}{U^l\leq U^{l'}}
\end{align*}

The \ref{rule:subtype} rule states that if $l$ is at most $l'$, then a term with security level $l$ is a subtype of a term with security level $l'$ that shares the same specialization type.
For example, $string^2$ is a subtype of $string^4$, since $2\leq4$ and the specialization types of both terms is $string$.

\begin{align*}
    \tag{Subsumption}\label{rule:subsumption} &\infrule{E\vdash x:T\quad T\leq T'}{E\vdash x:T'}
\end{align*}

The \ref{rule:subsumption} rule states that, given context $E$, if $x$ is well-typed at $T$ and $T$ is a subtype of $T'$, then $x$ is also well-typed at type $T'$.
Together with the \ref{rule:subtype} rule this states that, if $T$ is a term, then $x$ remains well-typed at higher security levels of $T$.

%\begin{align*}
%\tag{BasicSubBasic} &\infrule{l\leq l'}{B^l\leq B^{l'}}\\
%\tag{TupleSubTuple} &\infrule{S_i\leq S'\quad %U_i=S_i^\rho}{U_1\times...\times U_i\times...\times U_n\leq %U_1\times...\times S'^\rho\times...\times U_n}\\
%\tag{Level-level} &\level{l}=l\\
%\tag{Channel-level} &\level{ch[S]} = \level{S}\\
%\tag{Tuple-level} &\level{U_1\times...\times %U_n}=\max_{i=1}^{n}{\level{S_i}}& where\ S_i^\rho=U_i\\
%\tag{Basic-level} &\level{B^l}=l\\
%\tag{TypeSubLevel} &S\leq \level{S}\\
%\tag{TermAsChannel} &\infrule{E(M)=S^\rho\quad \level{S}=l}{E\vdash %M:ch[l]^\rho}
%\end{align*}

\subsection{Well-typing of expressions}
In order to use the type system with expressions in our extended rho-calculus, we need to define the well-typing of all expressions.
This is done by providing type rules that cover our syntax and consequently any expressions in our syntax.
\begin{align*}
    \tag{Nil}\label{rule:Nil} &E \vdash \nil
\end{align*}
The \ref{rule:Nil} rule states that any nil process is trivially well-typed.
This is true since the process contains no types.

\begin{align*}
    \tag{Input}\label{rule:Input} &\infrule{E\vdash x:ch[T]^l\quad E,y:T\vdash P}{E \vdash \inp{x}{y}P}
\end{align*}
The \ref{rule:Input} rule states that, given context $E$, if $x$ is well-typed at a channel type, that communicates type $T$, and $P$ is well-typed in a context where $y$ is well-typed at $T$, then $x(y).P$ is well-typed.
This ensures that communication is done on a channel and that $y$ has the type communicated by the channel when proceeding with $P$.

\begin{align*}
    \tag{Lift}\label{rule:Lift} &\infrule{E\vdash x:ch[T]^l\quad E \vdash M:T}{E\vdash \lift{x}{M}}
\end{align*}
The \ref{rule:Lift} rule states that, given context $E$, if $x$ is well-typed at a channel type, that communicates type $T$ and $M$ is well-typed at $T$, then $\lift{x}{M}$ is well-typed.
This ensures that communication is done on a channel and that $M$ has the type communicated by the channel.

\begin{align*}
    \tag{Drop}\label{rule:Drop} &\infrule{E \vdash P}{E\vdash \drop{x}}& where \drop{x} \equiv P
\end{align*}
The \ref{rule:Drop} rule states that, given context $E$, if the resulting process of dropping $x$ is well-typed, then dropping $x$ is well-typed.

\begin{align*}
    \tag{Parallel}\label{rule:Parallel} &\infrule{E\vdash P \quad E \vdash Q}{E \vdash P \para Q}
\end{align*}
The \ref{rule:Parallel} rule states that two well-typed processes in parallel is also a well-typed process.

\begin{align*}
    \tag{Quote}\label{rule:Quote} &\infrule{E \vdash x:T}{E\vdash \quot{P}:T}& where\ \quot{P} \equiv_N x
\end{align*}
The \ref{rule:Quote} rule states that, given context $E$, if the resulting name of quoting $P$ is well-typed at type $T$, then quoting $P$ is also well-typed at $T$.

\begin{align*}
    \tag{Condition}\label{rule:Condition} &\infrule{E\vdash \phi:bool\quad E\vdash P}{E \vdash [\phi] P}
\end{align*}
The \ref{rule:Condition} rule states that, given context $E$, if $\phi$ is well-typed at $bool$ and $P$ is well-typed, then the conditional process $[\phi]P$ is also well-typed. This ensures that the condition always evaluates to a boolean value.
\begin{align*}
    \tag{And}\label{rule:And} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \land \phi _2:bool}\\
    \tag{Or}\label{rule:Or} &\infrule{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \lor \phi _2:bool}\\
    \tag{Negation}\label{rule:Negation} &\infrule{E\vdash \phi :bool }{E\vdash \neg \phi :bool}
\end{align*}
\begin{align*}
    \tag{True}\label{rule:True} &E\vdash\top:bool\\
    \tag{False}\label{rule:False} &E\vdash\bot:bool
\end{align*}
The \ref{rule:And}, \ref{rule:Or} and \ref{rule:Negation} rules ensure that the $bool$ type is closed under these boolean operators. The \ref{rule:True} and \ref{rule:False} rules state that $\top$ and $\bot$ are trivially well-typed at $bool$.

\begin{align*}
    \tag{Relation}\label{rule:Relation} &\infrule{E\vdash M_1:U^l\quad E\vdash M_2:U^{l'}}{E\vdash M_1 \gamma\ M_2:bool}
\end{align*}
The \ref{rule:Relation} rule states that, given context $E$, if the terms $M_1$ and $M_2$ shares the same specialization type, then $M_1\gamma M_2$ is well-typed at $bool$. This ensures that the two terms are comparable with each other.

\begin{align*}
    \tag{Number}\label{rule:Number} &E\vdash n:{number^0}\\
    \tag{String}\label{rule:String} &E\vdash s:{string^0}
\end{align*}
The \ref{rule:Number} rule states that $n$ is trivially well-typed at $number^0$.
The \ref{rule:String} rule states that $s$ is trivially well-typed at $string^0$.
They both ensure that any numbers and strings used statically in the protocol have the lowest level of security possible, since the protocol is accessible to all environments.

\begin{align*}
    \tag{Tuple}\label{rule:Tuple} &\infrule{\level{T_i}=l\quad\forall i\ \level{T_i}\leq l\quad\forall i\ E\vdash M_i:T_i}{E\vdash (M_1,...,M_k):{T_1\times...\times T_k}^l}& where\ 1\leq i\leq k
\end{align*}
The \ref{rule:Tuple} rule states that, given context $E$, if some terms are well-typed at some types, and the highest security level of those types is $l$, then a tuple containing those terms are well-typed at the composition of the types the terms are well-typed at where the composition has a security level of $l$.
This ensures that the tuple type can not be composed of types with higher security level than itself.

\begin{align*}
    \tag{Operation}\label{rule:Operation} &\infrule{E\vdash f:T\ra T'\quad E\vdash M:T}{E\vdash fM:T'}
\end{align*}
The \ref{rule:Operation} rule states that, given context $E$, if $f$ is well-typed at a operation type and $M$ is well-typed at the argument type of that operation type, then $fM$ is well-typed at the resulting type of that operation type.
This ensures that any argument used with an operation follows the type definition of the operation.

%\textit{max(T)} is a operation which returns the maximum value off its input \textit{T}, according to the input \textit{T}s order.

%\begin{align*}
%\tag{Append} &\infrule{E \vdash x:T^l \quad E \vdash y:list^l}{E \vdash append(x,y):list^l}\\
%\tag{Head} &\infrule{E \vdash x:list^l}{E \vdash head(x):l}\\
%\tag{Tail} &\infrule{E \vdash x:list^l}{E \vdash tail(x):list^l}\\
%\tag{newBlock}& \infrule{E \vdash data:T \quad E \vdash previus : T}{E \vdash newBlock(data, previus) :T}\\
%\tag{getLatest}& \infrule{E \vdash chain :T}{E \vdash getLatest(chain):T}\\
%\tag{addToChain}& \infrule{E \vdash block:T \quad E \vdash chain:T}{E \vdash addToChain(block, chain):T}\\
%\tag{getLenght}& \infrule{E \vdash chain:T}{E \vdash getLenght(chain):int}\\
%\tag{isValid}& \infrule{E \vdash chain:T}{E \vdash isValid(chain):bool}
%\end{align*}
\section{Type Security}

\subsection{Subject Reduction}
If \ensuremath{E \vdash P} and \ensuremath{P\ra P'} then \ensuremath{E \vdash P'}.
We have to show that \ensuremath{\frac{}{P \ra P'}} holds for the rules, parallel, communication and structural congruent

\begin{align*}
    \infrule{P \ra P'}{P \para Q \ra P' \para Q} \tag{Parallel}
\end{align*}

If \ensuremath{E \vdash P} and \ensuremath{P \ra P'} then \ensuremath{E \vdash P'} We want to show that if \ensuremath{E \vdash P \para Q} then \ensuremath{E \vdash P' \para Q}. The type rule for parallel say \ensuremath{\frac{E \vdash P\quad E \vdash Q}{E \vdash P \para Q}} so if \ensuremath{E \vdash P'} then \ensuremath{\frac{E \vdash P' \quad E \vdash Q}{E \vdash P' \para Q}}

\begin{align*}
    \infrule{}{\lift{x}{M}\para\inp{x}{y}P\ra P\{M/y\}} \tag{Communication}
\end{align*}

Lemma Substitution
If \ensuremath{E,x:T \vdash P} and \ensuremath{E_2 \vdash M:T} then \ensuremath{E, E_2 \vdash P\{M/x \}}

\begin{align*}
    \infrule{P\equiv P'\quad P'\ra Q'\quad Q'\equiv Q}{P\ra Q} \tab{Structural Congruent}
\end{align*}

If \ensuremath{E \vdash P} then \ensuremath{E \vdash P'} We will want to show that if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q'}

Lemma Equivalent
If \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q}

By applying lemma equivalent to the structural congruent, we see that because \ensuremath{P \equiv Q} and \ensuremath{E \vdash P} then \ensuremath{E \vdash Q} and because \ensuremath{P \ra P'} and \ensuremath{E \vdash P'} then \ensuremath{E \vdash Q'}.

\subsection{Well typed}
If \ensuremath{E\vdash P} then \ensuremath{P\nrightarrow wrong}

If \ensuremath{E \vdash P} then \ensuremath{E \vdash P \nrightarrow wrong} and if \ensuremath{E \vdash Q} then \ensuremath{E \vdash Q \nrightarrow wrong}. This makes it so that that \ensuremath{E \vdash P \para Q \nrightarrow wrong}
\\\\

If \ensuremath{P \ra wrong} then must \ensuremath{P \para Q \ra wrong} true.\\
If \ensuremath{P \ra wrong} and \ensuremath{P \equiv Q} then must \ensuremath{Q \ra wrong} be true.

\begin{align*}
    \tag{Action} & \infrule{E \vdash P \quad P\ra P'}{E\vdash P'}\\
    \tag{Not Wrong}& \infrule{E \vdash P}{P \nrightarrow wrong}\\
    \tag{Para Wrong}& \infrule{P \ra wrong}{P\para Q \ra wrong}\\
    \tag{Wrong}& \infrule{E(x) = ch[T_1] \quad E \vdash M:T_2 \quad \level{T_2} > \level{T_1} }{\lift{x}{M} \ra wrong}
\end{align*}


%\fig{M: secret,c:secure\vdash \lift{c}{M}}{If \textit{M} is of type \textit{secret}, then \textit{c} should be of type \textit{secure}}{fig:sec}
%
%\fig{\frac{\Gamma \vdash M:Secret \quad \Gamma \vdash c:Secure}{\Gamma \vdash \lift{c}{M}}}{}{secret}
%
%\fig{\frac{\Gamma \vdash M:Public \quad \Gamma \vdash c:Insecure}{\Gamma \vdash \lift{c}{M}}}{}{public}

\FloatBarrier
