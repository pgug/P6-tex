\section{Type Security}
In order to determine whether a protocol is secure or not, we need a model that can express security.
We will construct a type system on top of our existing calculus, that will include security levels.
That way we can define integrity as a behavior of our types.

\fig{T::=&l\mid ch^l[T]\mid B^l\mid T\times T\\
B::=&int\mid string\mid list\mid bool}{The syntax of the typed security.}{typesyntax}

\noindent The syntax for your type security is shown in \figref{typesyntax}. Where \textit{l} is the level of security, and \textit{ch} is the channel. The set of security levels should be ordered for type rule in \figref{fig:typerules} (Type Upgrade) to apply. \textit{l} which is the level of security is in $ \mathbb{Z} $ and is ordered according to the order in $ \mathbb{Z} $.\\\\

\fig{E: names \rightharpoonup types}{Type environment E holds names and their types.}{typenames}

\noindent \textit{E} determines the type environment, and everything on the right side of the $ \vdash $ should hold for the type environment \textit{E}. \textit{x:T} determines that x is of type T , if it holds we can say that it is well typed, which in our context will make it secure.

\begin{figure}
\begin{align}
\tag{} & \frac{P\ra P'}{E\vdash P \ra E\vdash P'}\\
\tag{Nil} &E \vdash \nil\\
\tag{Input} &\frac{E(x) = ch^l[T]\quad E,y:T\vdash P}{E \vdash \inp{x}{y}P}\\
\tag{Lift} &\frac{E(x) = ch^l[T] \quad E \vdash M:T}{E\vdash \lift{x}{M}}\\
\tag{drop} &\frac{E \vdash P}{E\vdash \drop{x}}& where \drop{x} \equiv P\\
\tag{Parallel} &\frac{E\vdash P \quad E \vdash Q}{E \vdash P \para Q}\\
\tag{Quot} &\frac{E \vdash x}{E\vdash \quot{P}}& where\ \quot{P} \equiv_N x\\
\tag{Bool} &\frac{E\vdash \phi \quad E\vdash P}{E \vdash [\phi] P}\\
\tag{Condition} &\frac{E\vdash M_1:T \quad E\vdash M_2:T}{E\vdash M_1 \gamma\ M_2:T}\\
\tag{And} &\frac{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \land \phi _2:bool}\\
\tag{Or} &\frac{E\vdash \phi _1:bool \quad E\vdash \phi _2:bool}{E\vdash \phi _1 \lor \phi _2:bool}\\
\tag{not} &\frac{E\vdash \phi :bool }{E\vdash \neg \phi :bool}\\
\tag{Operation} &\frac{E\vdash f:T_1\times ... \times T_n\ra T\quad E\vdash M_i:T_i\quad 1\leq i \leq n}{E\vdash f(M_1,...,M_n):T}\\
\tag{Tuple} &\frac{E\vdash M_i:T_i \quad (1\leq i\leq n)}{E\vdash (M_1,...,M_n):T}&T = max(T_i)& 1\leq i\leq n\\
\tag{Int} &E\vdash n: int^L\\
\tag{String} &E\vdash s:string^L\\
\tag{Type Upgrade} &\frac{T\leq T'}{E, M:T\vdash M:T'}
\end{align}
\caption{Type rules}
\label{fig:typerules}
\end{figure}

\begin{align}
\tag{Append} &\frac{E \vdash x:T^L \quad E \vdash y:list^L}{E \vdash append(x,y):list^L}\\
\tag{Head} &\frac{E \vdash x:list^L}{E \vdash head(x):T^L}\\
\tag{Tail} &\frac{E \vdash x:list^L}{E \vdash tail(x):list^L}\\
\tag{newBlock}& \frac{E \vdash data:T \quad E \vdash previus : T}{E \vdash newBlock(data, previus) :T}\\
\tag{getLatest}& \frac{E \vdash chain :T}{E \vdash getLatest(chain):T}\\
\tag{addToChain}& \frac{E \vdash block:T \quad E \vdash chain:T}{E \vdash addToChain(block, chain):T}\\
\tag{getLenght}& \frac{E \vdash chain:T}{E \vdash getLenght(chain):int}\\
\tag{isValid}& \frac{E \vdash chain:T}{E \vdash isValid(chain):bool}
\end{align}

\textit{max(T)} is a operation which returns the maximum value off its input \textit{T}, according to the input \textit{T}s order.

%\fig{M: secret,c:secure\vdash \lift{c}{M}}{If \textit{M} is of type \textit{secret}, then \textit{c} should be of type \textit{secure}}{fig:sec}
%
%\fig{\frac{\Gamma \vdash M:Secret \quad \Gamma \vdash c:Secure}{\Gamma \vdash \lift{c}{M}}}{}{secret}
%
%\fig{\frac{\Gamma \vdash M:Public \quad \Gamma \vdash c:Insecure}{\Gamma \vdash \lift{c}{M}}}{}{public}

\FloatBarrier
