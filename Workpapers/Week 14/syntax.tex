\subsection{Syntax}
\begin{align*}
    P  ::= \; &  \nil & \text{nil} \\
      & \mid \inp{x}{y}P & \text{input} \\
      & \mid \lift{x}{M} & \text{lift} \\
      & \mid \drop{x} & \text{drop} \\
      & \mid P \para Q & \text{parallel} \\[3mm]
    x,y ::= \; & \quot{P} & \text{quote}\\
\end{align*}

Rho-Calculus is developed and described by L. G. Meredith and M. Radestock in \citep{Meredith2005}. We are building upon their work and extend the calculus to handle a blockchain protocol.

\begin{align*}
M::=\; & n \mid s \mid (M_1,...,M_k) \mid fM &for\ all\ k \geq 2
\end{align*}
We add an additional syntax rule, where $M$ ranges over terms, $n$ ranges over numbers, $s$ ranges over strings and $f$ ranges over operations.

\begin{align*}
\gamma ::=& \ =|\neq|<|>|\leq|\geq\\
\phi ::=& \ M_1\gamma M_2|\phi\land\phi|\phi\lor\phi|\neg\phi|\top|\bot\\
P::=& \ [\phi] P
\end{align*}
In addition to terms and processes we need to use conditional processes. This requires boolean expressions, denoted by \ensuremath{\phi}.

\begin{align*}
	\If{\phi}{P}{Q} = [\phi].P | [\neg \phi].Q
\end{align*}

To ease the writing of conditional branching, we use an if-then-else syntax.