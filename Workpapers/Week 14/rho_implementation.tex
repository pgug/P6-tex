\section{Implementation of blockchain}
In this section, an implementation of a simple blockchain written in $\rho$-calculus will be presented.

\subsection{Prerequisites}

\subsubsection{Operations}

\begin{align*}
    &newBlock(data,latest)\\
    &getLatest(chain)\\
    &addToChain(block,chain)\\
    &getLength(chain)\\
    &isValid(chain)\\
\end{align*}

\subsubsection{Condition syntax}

\begin{align*}
    if &= [cond,True,False] = [cond].True\ |\ [\neg cond].False
\end{align*}

\subsection{Overview}


\begin{align*}
    User &=\ !mineBlock \lift{}{data}\ |\ !addPeer\lift{}{peer}\\
    Client &= MineBlock\ |\ QueryLatest\ |\ QueryAll\ |\ BlockUpdate\ |\ \overline{BlockUpdate}|\\
    &\quad \overline{QueryLatest}\ |\ \overline{QueryAll}\ |\ peers\lift{}{0}\ |\ blockchain\lift{}{newBlockchain}
\end{align*}

\subsection{Client}

\begin{align*}
    MineBlock &=\ !mineBlock(data).blockchain(chain).(blockchain\\
        &\quad \lift{}{addToChain(newBlock(data,getLatest(chain)),chain)}|\\
        &\quad \overline{blockUpdate})\lift{}{newBlock(data, getLatest(chain))})\\
    QueryLatest &=\ !queryLatest(null).blockchain(chain).(blockchain\\
        &\quad \lift{}{chain}\ |\ \overline{blockUpdate}\lift{}{getLatest(chain)})\\
        QueryAll &=\ !queryAll(null).blockchain(chain).(blockchain\lift{}{chain}|\\
        &\quad \overline{blockUpdate}\lift{}{chain})\\
    BlockUpdate &=\ !blockUpdate(chain).blockchain(localchain).[indexOf(\\
        &\quad getLatest(chain))>indexOf(getLatest(localchain)),[hashOf(getLatest(\\
        &\quad localchain))=prevHashOf(getLatest(chain)),P_0,\\
        &\quad [getLength(chain)=1,P_1,P_1]],P_3]\\
    P_0 &=\ blockchain\lift{}{addToChain(getLatest(chain),localchain)}|\\
        &\quad \overline{blockUpdate}\lift{}{getLatest(chain)}\\
    P_1 &= P_3\ |\ \overline{queryAll}\lift{}{0}\\
    P_2 &= [isValid(chain) \land getLength(chain) > getLength(localchain),\\
        &\quad blockchain\lift{}{chain}\ |\ \overline{blockUpdate}\lift{}{getLatest(chain)},P_3]\\
    P_3 &= blockchain\lift{}{blockchain}
\end{align*}

\subsection{Peers}
The client exists in a network with a virtually infinite number of other clients.
The subset of these clients that our client can communicate with is called its peers.
Each peer is represented as a tuple of channel names, that lets the client know where to lift messages.

\begin{align*}
    Peer &= (blockUpdate, queryLatest, queryAll)
\end{align*}

The client stores its peers as a list lifted on the channel $peers$, similar to how the blockchain is stored.
When the client receives a new peer from its user, the peer is added to its peers.

\begin{align*}
    AddPeer &=\ !addPeer(peer).(peers(localpeers).peers\lift{}{(peer,localpeers)}|\\
        &\quad queryLatestOf(peer)\lift{}{0})\\
\end{align*}

This is done by inputting from peers into the name localpeers, and lifting localpeers on peers again, with the new peer added.
The client also needs to query this peer for its latest block.
This is done by indexing the queryLatest channel from the peer and lifting a message on it.

\subsection{Broadcasting}
In order for our client to communicate with more than one peer, we use broadcasting.
When a message is broadcast, it is lifted to all peers exactly once.
In previous client descriptions, any message that should be broadcast, is lifted on an overline channel name like $\overline{blockUpdate}$.
$\overline{BlockUpdate}$ is the process that inputs messages from $\overline{blockUpdate}$ and broadcasts them.
Note that although $\overline{BlockUpdate}$ only manages $\overline{blockUpdate}$, it is general enough to be repurposed for any other channel.

To explain how $\overline{BlockUpdate}$ works we first need to introduce broadcast tasks.

\begin{align*}
    BroadcastTask &= (peers, data)
\end{align*}

A broadcast task represents some data that should be lifted to a list of peers.

$\overline{BlockUpdate}$ consists of two parts: $BlockUpdateSetup$ and $BlockUpdateExecute$

\begin{align*}
    \overline{BlockUpdate} &= BlockUpdateSetup \para BlockUpdateExecute
\end{align*}

The idea is to have $BlockUpdateSetup$ setup the broadcast tasks and have $BlockUpdateExecute$ execute them.

$BlockUpdateSetup$ inputs messages on $\overline{blockUpdate}$ and lifts a $BroadcastTask$ with the known peers and the message data to $blockUpdateTasks$

\begin{align*}
    BlockUpdateSetup &=\ !\overline{blockUpdate}.(data).peers(localpeers).\\
    &\quad (peers\lift{}{localpeers}\ |\ blockUpdateTasks\lift{}{(localpeers,data)})
\end{align*}

$BlockUpdateExecute$ inputs tasks on $blockUpdateTasks$. When a task is received, it lifts a message on the $blockUpdate$ channel of the head of the task peers with the task message data. If the tail of the task peers is non-empty, it also lifts the remainder of the task to $blockUpdateTasks$, that is $BoradcastTask$ with the tail of the task peers and the message data.

\begin{align*}
    BlockUpdateExecute &=\ !blockUpdateTasks(task).(blockUpdateOf(head(peersOf(task)))\\
    &\quad \lift{}{dataOf(task)}\ |\ [isEmpty(tail(peersOf(task))),\nil,\\
    &\quad blockUpdateTasks\lift{}{(tail(peersOf(task)),dataOf(task))})
\end{align*}
