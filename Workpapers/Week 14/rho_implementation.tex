\section{Implementation of blockchain}
In this section, an implementation of a blockchain written in $\rho$-calculus will be presented. This is based on Naivechain, a naive implementation of a blockchain in javascript.

\subsection{Prerequisites}

\subsubsection{Operations}

\begin{align*}
    &newBlock(data,latest)\\
    &getLatest(chain)\\
    &addToChain(block,chain)\\
    &getLength(chain)\\
    &isValid(chain)\\
\end{align*}

\subsubsection{Condition syntax}

\begin{align*}
    if &= [cond,True,False] = [cond].True\ |\ [\neg cond].False
\end{align*}

\subsection{Overview}
The Rho-code is base on a javascript code of a block chain called naivechain \cite{naivechain}.
The names in the code is shortened for a better and shorter look. The enlarged names can be seen in the table \tabref{tab:short}.

\begin{table}[h]
\begin{center}
\resizebox{!}{0.48\textheight}{
\begin{tabular}{c|c}
a	&append					\\ \hline
aP	&addPeer				\\ \hline
AP	&AddPeer				\\ \hline
b	&blockchain				\\ \hline
bA	&broadcastQueryAll		\\ \hline
bO	&blockUpdateOf			\\ \hline
bT	&blockUpdateTasks		\\ \hline
bU	&broadcastBlockUpdate	\\ \hline
B	&Blockchain				\\ \hline
BA	&BroadcastQueryAll 		\\ \hline
BB	&BroadcastBlockUpdate 	\\ \hline
BE	&BlockUpdateExecute		\\ \hline
BL	&BroadcastQueryLatest 	\\ \hline
BS	&BlockUpdateSetup		\\ \hline
BT	&BroadcastTask			\\ \hline
BU	&BlockUpdate			\\ \hline
c	&chain					\\ \hline
C	&Client					\\ \hline
d	&data					\\ \hline
dO	&dataOf					\\ \hline
e	&peer					\\ \hline
eL	&emptyList				\\ \hline
h	&hashOf					\\ \hline
i	&indexOf				\\ \hline
l	&localChain				\\ \hline
lP	&localPeers				\\ \hline
mB	&mineBlock				\\ \hline
MB	&MineBlock				\\ \hline
n	&null					\\ \hline
nC	&newBlockchain			\\ \hline
p	&peers					\\ \hline
pO	&peersOf				\\ \hline
P	&Peer					\\ \hline
pH	&previusHashOf			\\ \hline
qA	&queryAll				\\ \hline
QA	&QueryAll				\\ \hline
qL	&queryLatest			\\ \hline
QL	&QueryLatest			\\ \hline
qO	&queryLatestOf			\\ \hline
t	&task					\\ \hline
u	&blockUpdate			\\ \hline
uT	&blockUpdateTasks		\\ \hline
U	&User					\\ 
\end{tabular}}
\end{center}
\caption{The table over the shortened names in the rho-code.}
\label{tab:short}
\end{table}

\FloatBarrier


\begin{align*}
	B &=\ !(U\para C)
\end{align*}

\begin{align*}
    U &=\ !mB \lift{}{D}\ |\ !aP\lift{}{peer}\\
    C &= MB\ |\ AP\ |\ QL\ |\ QA\ |\ BU\ |\\
    &\quad \ BB\ |\ BL\ |\ \ BA\ |\\
    &\quad \ p\lift{}{eL}\ |\ b\lift{}{nC}
\end{align*}

\subsection{Client}

\begin{align*}
    MB &=\ !mB(d).b(c).(b \lift{}{addToChain(newBlock(d,getLatest(c)),c)}| \ bU)\\
    &\quad \lift{}{newBlock(d, getLatest(c))})\\
    QL &=\ !qL(n).b(c).(b \lift{}{c}\ |\ \ bU\lift{}{getLatest(c)})\\
    QA &=\ !qA(n).b(c).(b\lift{}{c}| \ bU\lift{}{c})\\
    BU &=\ !u(c).b(l).[i( getLatest(c))>i(getLatest(l)),\\
    &\quad[h(getLatest( l))=pH(getLatest(c)),P_0, [getLenght(c)=1,P_1,P_1]],P_3]\\
    P_0 &=\ b\lift{}{addToChain(getLatest(c),l)}| \ bU\lift{}{getLatest(c)}\\
    P_1 &= P_3\ |\ bA \lift{}{0}\\
    P_2 &= [isValid(c) \land getLenght(c) > getLenght(l), b\lift{}{c}\ |\ bU \lift{}{getLatest(c)},P_3]\\
    P_3 &= b\lift{}{b}
\end{align*}

\subsection{Peers}
The client exists in a network with an arbitrarily large number of other clients.
The subset of these clients that our client can communicate with is called its peers.
Each peer is represented as a tuple of channel names, that lets the client know where to lift messages.

\begin{align*}
    P &= (u, qL, qA)
\end{align*}

The client stores its peers as a list lifted on the channel $p$, similar to how the blockchain is stored.
When the client receives a new peer from its user, the peer is added to its peers.

\begin{align*}
    AP &=\ !aP(e).(p(lP).p\lift{}{a(p,lP)}|\\
        &\quad qO(p)\lift{}{0})\\
\end{align*}

This is done by inputting from peers into the name $localpeers$, and lifting $localpeers$ on peers again, with the new peer added.
The client also needs to query this peer for its latest block.
This is done by indexing the $queryLatest$ channel from the peer and lifting a message on it.

\subsection{Broadcasting}
In order for our client to communicate with more than one peer, we need a system that enforces each message to be lifted to all peers exactly once. This is known as broadcasting, but since there is no primitive in the rho-calculus for this, we will describe a process that enforces broadcasting.

In previous client descriptions, any message that should be broadcast, is lifted on a channel with a broadcast prefix like $broadcastBlockUpdate$.
We will describe the process, $BroadcastBlockUpdate$, that inputs messages from $broadcastBlockUpdate$ and broadcasts them.
Note that although $BroadcastBlockUpdate$ only manages $broadcastBlockUpdate$, it is general enough to be repurposed for any other channel that needs broadcasting.

To explain how $BroadcastBlockUpdate$ works we first need to introduce broadcast tasks.

\begin{align*}
    BT &= (p, d)
\end{align*}

A broadcast task represents some data that should be lifted to a list of peers.

$BroadcastBlockUpdate$ consists of two parts: $BlockUpdateSetup$ and $BlockUpdateExecute$

\begin{align*}
    BB &= BS \para BE
\end{align*}

The idea is to have $BlockUpdateSetup$ setup the broadcast tasks and have $BlockUpdateExecute$ execute them.

$BlockUpdateSetup$ inputs messages on $broadcastBlockUpdate$ and lifts a broadcast task with the known peers and the message data to $blockUpdateTasks$

\begin{align*}
    BS &=\ !bU.(data).p(lP).\\
    &\quad (p\lift{}{lP}\ |\ uT\lift{}{(lP,d)})
\end{align*}

$BlockUpdateExecute$ inputs tasks on $blockUpdateTasks$. When a task is received, it lifts a message on the $blockUpdate$ channel of the head of the task peers with the task message data. If the tail of the task peers is non-empty, it also lifts the remainder of the task to $blockUpdateTasks$, that is a broadcast task with the tail of the task peers and the message data.

\begin{align*}
    BE &=\ !uT(task).(bO(head(pO(task)))\\
    &\quad \lift{}{dO(t)}\ |\ [tail(pO(task))=eL,\nil,\\
    &\quad bT\lift{}{(tail(pO(t)),dO(t))})
\end{align*}
