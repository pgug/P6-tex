\section{Implementation of blockchain}
In this section, an implementation of a simple blockchain written in $\rho$-calculus will be presented.

\subsection{Prerequisites}

\subsubsection{Operations}

\begin{align*}
    &newBlock(data,latest)\\
    &getLatest(chain)\\
    &addToChain(block,chain)\\
    &getLength(chain)\\
    &isValid(chain)\\
\end{align*}

\subsubsection{Condition syntax}

\begin{align*}
    if &= [cond,True,False] = [cond].True\ |\ [\neg cond].False
\end{align*}

\subsection{Overview}


\begin{align*}
    User &=\ !mineBlock \lift{}{data}\ |\ !addPeer\lift{}{peer}\\
    Client &= MineBlock\ |\ QueryLatest\ |\ QueryAll\ |\ BlockUpdate\ |\ BroadcastBlockUpdate\ |\\
    &\quad \ BroadcastQueryLatest\ |\ \ BroadcastQueryAll \ |\ peers\lift{}{emptyList}\ |\ blockchain\lift{}{newBlockchain}
\end{align*}

\subsection{Client}

\begin{align*}
    MineBlock &=\ !mineBlock(data).blockchain(chain).(blockchain\\
        &\quad \lift{}{addToChain(newBlock(data,getLatest(chain)),chain)}|\\
        &\quad \ broadcastBlockUpdate)\lift{}{newBlock(data, getLatest(chain))})\\
    QueryLatest &=\ !queryLatest(null).blockchain(chain).(blockchain\\
        &\quad \lift{}{chain}\ |\ \ broadcastBlockUpdate\lift{}{getLatest(chain)})\\
        QueryAll &=\ !queryAll(null).blockchain(chain).(blockchain\lift{}{chain}|\\
        &\quad \ broadcastBlockUpdate\lift{}{chain})\\
    BlockUpdate &=\ !blockUpdate(chain).blockchain(localchain).[indexOf(\\
        &\quad getLatest(chain))>indexOf(getLatest(localchain)),[hashOf(getLatest(\\
        &\quad localchain))=prevHashOf(getLatest(chain)),P_0,\\
        &\quad [getLength(chain)=1,P_1,P_1]],P_3]\\
    P_0 &=\ blockchain\lift{}{addToChain(getLatest(chain),localchain)}|\\
        &\quad \ broadcastBlockUpdate\lift{}{getLatest(chain)}\\
    P_1 &= P_3\ |\ broadcastQueryAll \lift{}{0}\\
    P_2 &= [isValid(chain) \land getLength(chain) > getLength(localchain),\\
        &\quad blockchain\lift{}{chain}\ |\ broadcastBlockUpdate \lift{}{getLatest(chain)},P_3]\\
    P_3 &= blockchain\lift{}{blockchain}
\end{align*}

\subsection{Peers}
The client exists in a network with an arbitrarily large number of other clients.
The subset of these clients that our client can communicate with is called its peers.
Each peer is represented as a tuple of channel names, that lets the client know where to lift messages.

\begin{align*}
    Peer &= (blockUpdate, queryLatest, queryAll)
\end{align*}

The client stores its peers as a list lifted on the channel $peers$, similar to how the blockchain is stored.
When the client receives a new peer from its user, the peer is added to its peers.

\begin{align*}
    AddPeer &=\ !addPeer(peer).(peers(localpeers).peers\lift{}{append(peer,localpeers)}|\\
        &\quad queryLatestOf(peer)\lift{}{0})\\
\end{align*}

This is done by inputting from peers into the name $localpeers$, and lifting $localpeers$ on peers again, with the new peer added.
The client also needs to query this peer for its latest block.
This is done by indexing the $queryLatest$ channel from the peer and lifting a message on it.

\subsection{Broadcasting}
In order for our client to communicate with more than one peer, we need a system that enforces each message to be lifted to all peers exactly once. This is known as broadcasting, but since there is no primitive in the rho-calculus for this, we will describe a process that enforces broadcasting.

In previous client descriptions, any message that should be broadcast, is lifted on a channel with a broadcast prefix like $broadcastBlockUpdate$.
We will describe the process, $BroadcastBlockUpdate$, that inputs messages from $broadcastBlockUpdate$ and broadcasts them.
Note that although $BroadcastBlockUpdate$ only manages $broadcastBlockUpdate$, it is general enough to be repurposed for any other channel that needs broadcasting.

To explain how $BroadcastBlockUpdate$ works we first need to introduce broadcast tasks.

\begin{align*}
    BroadcastTask &= (peers, data)
\end{align*}

A broadcast task represents some data that should be lifted to a list of peers.

$BroadcastBlockUpdate$ consists of two parts: $BlockUpdateSetup$ and $BlockUpdateExecute$

\begin{align*}
    BroadcastBlockUpdate &= BlockUpdateSetup \para BlockUpdateExecute
\end{align*}

The idea is to have $BlockUpdateSetup$ setup the broadcast tasks and have $BlockUpdateExecute$ execute them.

$BlockUpdateSetup$ inputs messages on $broadcastBlockUpdate$ and lifts a broadcast task with the known peers and the message data to $blockUpdateTasks$

\begin{align*}
    BlockUpdateSetup &=\ !broadcastBlockUpdate.(data).peers(localpeers).\\
    &\quad (peers\lift{}{localpeers}\ |\ blockUpdateTasks\lift{}{(localpeers,data)})
\end{align*}

$BlockUpdateExecute$ inputs tasks on $blockUpdateTasks$. When a task is received, it lifts a message on the $blockUpdate$ channel of the head of the task peers with the task message data. If the tail of the task peers is non-empty, it also lifts the remainder of the task to $blockUpdateTasks$, that is a broadcast task with the tail of the task peers and the message data.

\begin{align*}
    BlockUpdateExecute &=\ !blockUpdateTasks(task).(blockUpdateOf(head(peersOf(task)))\\
    &\quad \lift{}{dataOf(task)}\ |\ [tail(peersOf(task))=emptyList,\nil,\\
    &\quad blockUpdateTasks\lift{}{(tail(peersOf(task)),dataOf(task))})
\end{align*}
