\section{Implementation of blockchain}
In this section, an implementation of a blockchain written in $\rho$-calculus will be presented. This is based on Naivechain, a naive implementation of a blockchain in javascript.

\subsection{Prerequisites}

\subsubsection{Operations}

\begin{align*}
    &newBlock(data,latest)\\
    &getLatest(chain)\\
    &addToChain(block,chain)\\
    &getLength(chain)\\
    &isValid(chain)\\
\end{align*}

\subsubsection{Condition syntax}

\begin{align*}
    if\ Cond\ then\ P\ else\ Q = [Cond].P | [\neg Cond].Q
\end{align*}

\subsection{Overview}
The Rho-code is base on a javascript code of a block chain called naivechain \cite{naivechain}.
The names in the code is shortened for a better and shorter look. The enlarged names can be seen in the table \tabref{tab:short}.

\begin{table}[h]
\begin{center}
\resizebox{!}{0.48\textheight}{
\begin{tabular}{c|c}
ap	&addPeer				\\ \hline
AP	&AddPeer				\\ \hline
b	&blockchain				\\ \hline
ba	&broadcastQueryAll		\\ \hline
bt	&blockUpdateTasks		\\ \hline
bu	&broadcastBlockUpdate	\\ \hline
BA	&BroadcastQueryAll 		\\ \hline
BE	&BlockUpdateExecute		\\ \hline
BL	&BroadcastQueryLatest 	\\ \hline
BS	&BlockUpdateSetup		\\ \hline
BU	&BroadcastBlockUpdate 	\\ \hline
c	&chain					\\ \hline
C	&Client					\\ \hline
d	&data					\\ \hline
el	&emptyList				\\ \hline
lc	&localChain				\\ \hline
lp	&localPeers				\\ \hline
mb	&mineBlock				\\ \hline
MB	&MineBlock				\\ \hline
n	&null					\\ \hline
nb	&newBlockchain			\\ \hline
p	&peer					\\ \hline
ps	&peers					\\ \hline
qa	&queryAll				\\ \hline
QA	&QueryAll				\\ \hline
ql	&queryLatest			\\ \hline
QL	&QueryLatest			\\ \hline
t	&task					\\ \hline
u	&blockUpdate			\\ \hline
U	&BlockUpdate			\\ \hline
ut	&blockUpdateTasks		\\ \hline
\end{tabular}}
\end{center}
\caption{The table over the shortened names in the rho-code.}
\label{tab:short}
\end{table}

\FloatBarrier

\begin{align*}
    C &= MB\ |\ AP\ |\ QL\ |\ QA\ |\ U\ |\\
    &\quad \ BU\ |\ BL\ |\ \ BA\ |\\
    &\quad \ p\lift{}{el}\ |\ b\lift{}{nb}
\end{align*}

\subsection{Client}

\begin{align*}
    MB &=\ !mb(d).b(c).(b \lift{}{addToChain(newBlock(d,getLatest(c)),c)}| \ bu)\\
    &\quad \lift{}{newBlock(d, getLatest(c))})\\
    QL &=\ !ql(n).b(c).(b \lift{}{c}\ |\ \ bu\lift{}{getLatest(c)})\\
    QA &=\ !qa(n).b(c).(b\lift{}{c}| \ bu\lift{}{c})\\
    U &=\ !u(c).b(lc).[indexOf( getLatest(c))>indexOf(getLatest(lc)),\\
    &\quad[hashOf(getLatest(lc))=previousHashOf(getLatest(c)),P_0, [getLength(c)=1,P_1,P_2]],P_3]\\
    P_0 &=\ b\lift{}{addToChain(getLatest(c),lc)}| \ bu\lift{}{getLatest(c)}\\
    P_1 &= P_3\ |\ ba \lift{}{0}\\
    P_2 &= [isValid(c) \land getLength(c) > getLength(lc), b\lift{}{c}\ |\ bu \lift{}{getLatest(c)},P_3]\\
    P_3 &= b\lift{}{b}
\end{align*}

\subsection{Peers}
The client exists in a network with an arbitrarily large number of other clients.
The subset of these clients that our client can communicate with is called its peers.
Each peer is represented as a tuple of channel names, that lets the client know where to lift messages.

\begin{align*}
    Peer &= (u, ql, qa)
\end{align*}

The client stores its peers as a list lifted on the channel $p$, similar to how the blockchain is stored.
When the client receives a new peer from its user, the peer is added to its peers.

\begin{align*}
    AP &=\ !ap(p).(ps(lp).ps\lift{}{append(p,lp)}|\\
        &\quad queryLatestOf(p)\lift{}{0})\\
\end{align*}

This is done by inputting from peers into the name $localpeers$, and lifting $localpeers$ on peers again, with the new peer added.
The client also needs to query this peer for its latest block.
This is done by indexing the $queryLatest$ channel from the peer and lifting a message on it.

\subsection{Broadcasting}
In order for our client to communicate with more than one peer, we need a system that enforces each message to be lifted to all peers exactly once. This is known as broadcasting, but since there is no primitive in the rho-calculus for this, we will describe a process that enforces broadcasting.

In previous client descriptions, any message that should be broadcast, is lifted on a channel with a broadcast prefix like $broadcastBlockUpdate$.
We will describe the process, $BroadcastBlockUpdate$, that inputs messages from $broadcastBlockUpdate$ and broadcasts them.
Note that although $BroadcastBlockUpdate$ only manages $broadcastBlockUpdate$, it is general enough to be repurposed for any other channel that needs broadcasting.

To explain how $BroadcastBlockUpdate$ works we first need to introduce broadcast tasks.

\begin{align*}
    BroadcastTask &= (ps, d)
\end{align*}

A broadcast task represents some data that should be lifted to a list of peers.

$BroadcastBlockUpdate$ consists of two parts: $BlockUpdateSetup$ and $BlockUpdateExecute$

\begin{align*}
    BU &= BS \para BE
\end{align*}

The idea is to have $BlockUpdateSetup$ setup the broadcast tasks and have $BlockUpdateExecute$ execute them.

$BlockUpdateSetup$ inputs messages on $broadcastBlockUpdate$ and lifts a broadcast task with the known peers and the message data to $blockUpdateTasks$

\begin{align*}
    BS &=\ !bu.(d).ps(lp).\\
    &\quad (ps\lift{}{lp}\ |\ ut\lift{}{(lp,d)})
\end{align*}

$BlockUpdateExecute$ inputs tasks on $blockUpdateTasks$. When a task is received, it lifts a message on the $blockUpdate$ channel of the head of the task peers with the task message data. If the tail of the task peers is non-empty, it also lifts the remainder of the task to $blockUpdateTasks$, that is a broadcast task with the tail of the task peers and the message data.

\begin{align*}
    BE &=\ !ut(t).(blockUpdateOf(head(peersOf(t)))\\
    &\quad \lift{}{dataOf(t)}\ |\ [tail(peersOf(t))=el,\nil,\\
    &\quad bt\lift{}{(tail(peersOf(t)),dataOf(t))})
\end{align*}
